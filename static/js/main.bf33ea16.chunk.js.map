{"version":3,"sources":["services/index.ts","helpers/TitleGenerator.ts","helpers/AlbumParser.ts","App.tsx","reportWebVitals.ts","index.tsx"],"names":["getLocationDateForPhoto","_ref","Object","asyncToGenerator","regenerator_default","a","mark","_callee","coordinates","data","res","wrap","_context","prev","next","fetch","concat","latitude","longitude","sent","ok","json","items","abrupt","Promise","reject","JSON","stringify","status","statusText","stop","_x","apply","this","arguments","getCSVFile","_ref3","_callee3","url","_context3","text","_x4","TITLE_PREFIXS","coinFlip","Math","floor","random","getEstimatedDistance","pointA","pointB","deltaLatitude","PI","deltaLongitude","halfChordLength","cos","sin","atan2","sqrt","parseCSVDataIntoMetaData","map","row","_row$split","split","_row$split2","slicedToArray","timestamp","parseMetaDataIntoPhotoArray","metaData","lastPhoto","photos","_iterator","_step","newPhotoTime","majorDistanceBetweenLastPhoto","majorTimeDifference","newPhoto","oldPhotoTime","fetchGeoLocationData","address","undefined","_createForOfIteratorHelper","s","n","done","value","Date","objectSpread","ceil","abs","getTime","country","countryName","city","state","weekend","getDay","weather","temperature","t0","console","warn","push","t1","e","f","finish","parseMetaDataIntoAlbum","album","suggestedTitles","averageTemperature","reduce","b","length","titles","temp","i","title","includes","charAt","toUpperCase","slice","generateTitles","datasetUrls","getAlbumTitles","_callee2","_context2","all","_ref2","rows","photoData","App","_useState","useState","_useState2","albumTitles","setAlbumTitles","handleClick","albums","React","createElement","style","textAlign","onClick","Fragment","key","j","reportWebVitals","onPerfEntry","Function","__webpack_require__","then","bind","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","react_default","StrictMode","src_App","document","getElementById"],"mappings":"oNAKMA,SAAuB,eAAAC,EAAAC,OAAAC,EAAA,EAAAD,CAAAE,EAAAC,EAAAC,KAAG,SAAAC,EAAOC,GAAP,IAAAC,EAAAC,EAAA,OAAAN,EAAAC,EAAAM,KAAA,SAAAC,GAAA,cAAAA,EAAAC,KAAAD,EAAAE,MAAA,cAAAF,EAAAE,KAAA,EAETC,MAAK,0DAAAC,OAA2DR,EAAYS,SAAvE,OAAAD,OAAqFR,EAAYU,UAAjG,uBAAAF,OAJC,gDAEG,YAEtBP,EAFsBG,EAAAO,MAGpBC,GAHoB,CAAAR,EAAAE,KAAA,gBAAAF,EAAAE,KAAA,EAKNL,EAAKY,OALC,YAKlBX,EALkBE,EAAAO,MAMjBG,MANiB,CAAAV,EAAAE,KAAA,gBAAAF,EAAAW,OAAA,SAMHb,GANG,QAOnBc,QAAQC,OAAO,6CAA+CC,KAAKC,UAAUjB,IAP1D,QAAAE,EAAAE,KAAA,wBAAAF,EAAAW,OAAA,SAWjBC,QAAQC,OAAO,wCAA0ChB,EAAKmB,OAAS,KAAOnB,EAAKoB,WAAa,MAX/E,yBAAAjB,EAAAkB,SAAAvB,MAAH,gBAAAwB,GAAA,OAAA9B,EAAA+B,MAAAC,KAAAC,YAAA,IA+BvBC,EAAU,eAAAC,EAAAlC,OAAAC,EAAA,EAAAD,CAAAE,EAAAC,EAAAC,KAAG,SAAA+B,EAAOC,GAAP,IAAA5B,EAAA,OAAAN,EAAAC,EAAAM,KAAA,SAAA4B,GAAA,cAAAA,EAAA1B,KAAA0B,EAAAzB,MAAA,cAAAyB,EAAAzB,KAAA,EACGC,MAAMuB,GADT,YACT5B,EADS6B,EAAApB,MAERC,GAFQ,CAAAmB,EAAAzB,KAAA,eAAAyB,EAAAhB,OAAA,SAIJb,EAAI8B,QAJA,cAAAD,EAAAhB,OAAA,SAQJC,QAAQC,OAAO,wCAA0Cf,EAAIkB,OAAS,KAAOlB,EAAImB,WAAa,MAR1F,wBAAAU,EAAAT,SAAAO,MAAH,gBAAAI,GAAA,OAAAL,EAAAJ,MAAAC,KAAAC,YAAA,UClCVQ,EAAgB,CAClB,gBACA,WACA,aACA,gBAKEC,EAAW,WAEb,OAAwC,GAAjCC,KAAKC,MAAsB,EAAhBD,KAAKE,kiCCP3B,IAgBMC,EAAuB,SAACC,EAAqBC,GAG/C,IAAMC,GAAiBD,EAAOhC,SAAW+B,EAAO/B,UAAY2B,KAAKO,GAlBtD,IAmBLC,GAAkBH,EAAO/B,UAAY8B,EAAO9B,WAAa0B,KAAKO,GAnBzD,IAqBLE,EAAkBT,KAAKU,IACzBN,EAAO/B,SAAW2B,KAAKO,GAtBhB,KAsB+BP,KAAKU,IAAIL,EAAOhC,SAAW2B,KAAKO,GAtB/D,KAuBLP,KAAKW,IAAIH,EAAe,GAAKR,KAAKW,IAAIH,EAAe,GACrDR,KAAKW,IAAIL,EAAc,GAAKN,KAAKW,IAAIL,EAAc,GAIzD,OA7BW,MA2Ba,EAAIN,KAAKY,MAAMZ,KAAKa,KAAKJ,GAAkBT,KAAKa,KAAK,EAAIJ,MAK/EK,EAA2B,SAACjD,GAC9B,OAAOA,EAAKkD,IAAI,SAACC,GAAQ,IAAAC,EACoBD,EAAIE,MAAM,KAD9BC,EAAA7D,OAAA8D,EAAA,EAAA9D,CAAA2D,EAAA,GAErB,MAAO,CAACI,UAFaF,EAAA,GAEFvD,YAAa,CAACS,UAFZ8C,EAAA,GAEiC7C,WAFjC6C,EAAA,QAMvBG,EAA2B,eAAAjE,EAAAC,OAAAC,EAAA,EAAAD,CAAAE,EAAAC,EAAAC,KAAG,SAAAC,EAAO4D,GAAP,IAAAC,EAAAC,EAAAC,EAAAC,EAAA9D,EAAA+D,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAA,OAAA1E,EAAAC,EAAAM,KAAA,SAAAC,GAAA,cAAAA,EAAAC,KAAAD,EAAAE,MAAA,OAE5BsD,OAAmBW,EAEnBV,EAAkB,GAJUC,EAAAU,EAMdb,GANcvD,EAAAC,KAAA,EAAAyD,EAAAW,IAAA,WAAAV,EAAAD,EAAAY,KAAAC,KAAA,CAAAvE,EAAAE,KAAA,YAMtBL,EANsB8D,EAAAa,MAQhB3E,EAAKD,YAAYS,SAChBR,EAAKD,YAAYU,UAExBsD,EAAe,IAAIa,KAAK5E,EAAKwD,WAE/BQ,GAAyC,EACzCC,GAA+B,GAE7BC,EAhBsBzE,OAAAoF,EAAA,EAAApF,CAAA,GAgBAkE,IACnB5D,YAAcC,EAAKD,YAC5BmE,EAASV,UAAYxD,EAAKwD,eAKVc,GAAbX,IAEKQ,EAAe,IAAIS,KAAKjB,EAAUH,WAExCQ,EAAgC1B,EAAqBqB,EAAU5D,YAAaC,EAAKD,aA9DnE,EAgEdkE,EAAsB9B,KAAK2C,KAAK3C,KAAK4C,KAAKZ,EAAaa,UAAYjB,EAAaiB,WAAa,QAAa,IAGzGhB,IAAiCC,EAhCR,CAAA9D,EAAAE,KAAA,gBAAAF,EAAAC,KAAA,GAAAD,EAAAE,KAAA,GAoCed,EAAwBS,EAAKD,aApC5C,QAoCdqE,EApCcjE,EAAAO,KA2Cd2D,EAAUD,EAAqBvD,MAAM,GAAGwD,QAC9CH,EAASe,QAAUZ,EAAQa,YAC3BhB,EAASiB,KAAOd,EAAQc,KACxBjB,EAASkB,MAAQf,EAAQe,MACzBlB,EAASmB,QAAUtB,EAAauB,SAAW,GAAK,EAChDpB,EAASqB,QAAU,QACnBrB,EAASsB,YAAc,GAjDHrF,EAAAE,KAAA,iBAAAF,EAAAC,KAAA,GAAAD,EAAAsF,GAAAtF,EAAA,UAqDpBuF,QAAQC,KAAK,0CAAAxF,EAAAsF,IArDO,QAyD5B9B,EAAYO,EACZN,EAAOgC,KAAK1B,GA1DgB,QAAA/D,EAAAE,KAAA,gBAAAF,EAAAE,KAAA,iBAAAF,EAAAC,KAAA,GAAAD,EAAA0F,GAAA1F,EAAA,SAAA0D,EAAAiC,EAAA3F,EAAA0F,IAAA,eAAA1F,EAAAC,KAAA,GAAAyD,EAAAkC,IAAA5F,EAAA6F,OAAA,mBAAA7F,EAAAW,OAAA,SA6DzB8C,GA7DyB,yBAAAzD,EAAAkB,SAAAvB,EAAA,gCAAH,gBAAAwB,GAAA,OAAA9B,EAAA+B,MAAAC,KAAAC,YAAA,GAgE3BwE,EAAyB,SAACrC,GAC5B,IAAIsC,EACJ,CACItC,OAAQA,EACRuC,gBAAiB,GACjBC,mBAAoBxC,EAAOyC,OAAO,SAACzG,EAAG0G,GAAJ,OAAU1G,IAAM0G,EAAEd,aAAc,GAAK5B,EAAO2C,OAC9EtB,QAASrB,EAAO,GAAGqB,QACnBM,QAAS3B,EAAO,GAAG2B,SAGvB,OADAW,EAAMC,gBDtGa,SAACD,GAEpB,IAAIM,EAAmB,GAGnBC,EAAuB,GAAhBtE,KAAKE,SACbH,MAAYuE,IAAS,GAExB,IAAI,IAAIC,EAAI,EAAGA,GAfgB,GAeSA,IACxC,CACI,IAAIC,EAAQ,GAETzE,IAAYyE,GAAS1E,EAAcE,KAAKC,MAAMD,KAAKE,SAAWJ,EAAcsE,SACvErE,KAAcgE,EAAMtC,OAAO,GAAGyB,SAE/BnD,MAAYyE,GAAST,EAAMX,SAC9BoB,GAAUzE,IAAa,eAAiB,qBAEvCyE,GAAST,EAAMX,QAAU,WAG3BrD,MAOKyE,GAFDF,GAAQ,EAEE,QAELA,GAAQ,GAEH,OAELA,GAAQ,GAEH,QAELA,GAAQ,GAEH,QAIA,UAIdvE,IAAYyE,GAAST,EAAMjB,QACzB0B,GAAST,EAAMtC,OAAO,GAAGwB,MAG3BoB,EAAOI,SAASD,GAEfD,IAKAF,EAAOZ,KAAKe,EAAME,OAAO,GAAGC,cAAgBH,EAAMI,MAAM,IAGhE,OAAOP,ECwCiBQ,CAAed,GAChCA,GCjHLe,EACN,CACE,mIACA,mIACA,oIAGIC,EAAc,eAAA1H,EAAAC,OAAAC,EAAA,EAAAD,CAAAE,EAAAC,EAAAC,KAAG,SAAAsH,IAAA,OAAAxH,EAAAC,EAAAM,KAAA,SAAAkH,GAAA,cAAAA,EAAAhH,KAAAgH,EAAA/G,MAAA,cAAA+G,EAAAtG,OAAA,SAGdC,QAAQsG,IAAIJ,EAAY/D,IAAZ,eAAAoE,EAAA7H,OAAAC,EAAA,EAAAD,CAAAE,EAAAC,EAAAC,KAAiB,SAAAC,EAAO+B,GAAP,IAAA7B,EAAAuH,EAAA7D,EAAA8D,EAAA,OAAA7H,EAAAC,EAAAM,KAAA,SAAAC,GAAA,cAAAA,EAAAC,KAAAD,EAAAE,MAAA,cAAAF,EAAAE,KAAA,EACfqB,EAAWG,GADI,cAC5B7B,EAD4BG,EAAAO,KAE5B6G,EAAOvH,EAAKqD,MAAM,MAGlBK,EAA4BT,EAAyBsE,GALzBpH,EAAAE,KAAA,EAMDoD,EAA4BC,GAN3B,cAM5B8D,EAN4BrH,EAAAO,KAAAP,EAAAW,OAAA,SAS3BmF,EAAuBuB,IATI,wBAAArH,EAAAkB,SAAAvB,MAAjB,gBAAAwB,GAAA,OAAAgG,EAAA/F,MAAAC,KAAAC,YAAA,MAHE,wBAAA2F,EAAA/F,SAAA8F,MAAH,yBAAA3H,EAAA+B,MAAAC,KAAAC,YAAA,GAkDLgG,MAjCf,WAAe,IAAAC,EAEyBC,mBAAkB,IAF3CC,EAAAnI,OAAA8D,EAAA,EAAA9D,CAAAiI,EAAA,GAENG,EAFMD,EAAA,GAEOE,EAFPF,EAAA,GAIPG,EAAW,eAAApG,EAAAlC,OAAAC,EAAA,EAAAD,CAAAE,EAAAC,EAAAC,KAAG,SAAA+B,IAAA,IAAAoG,EAAA,OAAArI,EAAAC,EAAAM,KAAA,SAAA4B,GAAA,cAAAA,EAAA1B,KAAA0B,EAAAzB,MAAA,cAAAyB,EAAAzB,KAAA,EACG6G,IADH,OACZc,EADYlG,EAAApB,KAElBoH,EAAeE,GAFG,wBAAAlG,EAAAT,SAAAO,MAAH,yBAAAD,EAAAJ,MAAAC,KAAAC,YAAA,GAKjB,OACEwG,MAAAC,cAAA,OAAKC,MAAO,CAACC,UAAW,WAEtBH,MAAAC,cAAA,0CACAD,MAAAC,cAAA,UAAQG,QAASN,GAAjB,mBACAE,MAAAC,cAAA,WAEAD,MAAAC,cAAA,WACGL,EAAY3E,IAAI,SAACgD,EAAOQ,GAAR,OACfuB,MAAAC,cAAAD,MAAAK,SAAA,KACEL,MAAAC,cAAA,OAAKK,IAAK7B,GACRuB,MAAAC,cAAA,UAAKhC,EAAMjB,QAAX,MAAuBiB,EAAMX,QAA7B,MAAyCW,EAAME,mBAA/C,SACDF,EAAMC,gBAAgBjD,IAAI,SAACyD,EAAO6B,GAAR,OACvBP,MAAAC,cAAA,OAAKK,IAAKC,GAAI7B,MAGlBsB,MAAAC,cAAA,iBCzCGO,EAZS,SAACC,GACnBA,GAAeA,aAAuBC,UACxCC,EAAA9C,EAAA,GAAA+C,KAAAD,EAAAE,KAAA,UAAqBD,KAAK,SAAArJ,GAAiD,IAA9CuJ,EAA8CvJ,EAA9CuJ,OAAQC,EAAsCxJ,EAAtCwJ,OAAQC,EAA8BzJ,EAA9ByJ,OAAQC,EAAsB1J,EAAtB0J,OAAQC,EAAc3J,EAAd2J,QAC3DJ,EAAOL,GACPM,EAAON,GACPO,EAAOP,GACPQ,EAAOR,GACPS,EAAQT,MCHdU,IAASC,OACPC,EAAA1J,EAAAsI,cAACoB,EAAA1J,EAAM2J,WAAP,KACED,EAAA1J,EAAAsI,cAACsB,EAAD,OAEFC,SAASC,eAAe,SAM1BjB","file":"static/js/main.bf33ea16.chunk.js","sourcesContent":["import { Coordinates } from \"../models/Utils\";\r\n\r\nconst WEATHER_API_KEY = \"6680ff9e560641eca5f191603220504\";\r\nconst HERE_DOT_COM_API_KEY = \"Znc7h30xPVDLqOCjKagiaN7z8seznJDP7_ZTOK3-V6M\";\r\n\r\nconst getLocationDateForPhoto = async (coordinates: Coordinates): Promise<any> => {\r\n    \r\n    const data = await fetch(`https://revgeocode.search.hereapi.com/v1/revgeocode?at=${coordinates.latitude}%2C${coordinates.longitude}&lang=en-US&apiKey=${HERE_DOT_COM_API_KEY}`)\r\n    if(data.ok)\r\n    {\r\n        const res = await data.json();\r\n        if(res.items) return res;\r\n        else Promise.reject('Query response format was incorrect, JSON=' + JSON.stringify(res));\r\n    }\r\n    else\r\n    {\r\n        return Promise.reject('Failed to Query Location Data, status' + data.status + \" (\" + data.statusText + \")\");\r\n    }\r\n}\r\n\r\nconst getWeatherOnDate = async (date: string, coordinates: Coordinates): Promise<any> => {\r\n    \r\n    const geoTemperature = await fetch(`http://api.worldweatheronline.com/premium/v1/past-weather.ashx?q=${coordinates.latitude}%2C${coordinates.longitude}4&key=${WEATHER_API_KEY}&date=2020-03-30&format=json`);\r\n        \r\n    if(geoTemperature.ok)\r\n    {\r\n        const json = await geoTemperature.json();\r\n        return json.data.weather;\r\n    }\r\n    else\r\n    {\r\n        return Promise.reject('Failed to Query Temperature Data, status' + geoTemperature.status + \" (\" + geoTemperature.statusText + \")\");\r\n    }\r\n\r\n}\r\n\r\nconst getCSVFile = async (url: string): Promise<string> => {\r\n    const res = await fetch(url);\r\n    if(res.ok)\r\n    {\r\n        return res.text();\r\n    }\r\n    else\r\n    {\r\n        return Promise.reject('Failed to Query Location Data, status' + res.status + \" (\" + res.statusText + \")\");\r\n    }\r\n};\r\n\r\nexport {getCSVFile, getWeatherOnDate, getLocationDateForPhoto};","import { Album } from \"../models/Album\";\r\n\r\nconst TITLE_PREFIXS = [\r\n    \"Adventure in \",\r\n    \"Trip to \",\r\n    \"Escape to \",\r\n    \"Dreaming of \",\r\n]\r\n\r\nconst TITLES_TO_GENERATE: number = 10;\r\n\r\nconst coinFlip = (): boolean => \r\n{\r\n    return Math.floor(Math.random() * 2) == 1;\r\n}\r\n\r\nconst generateTitles = (album: Album): string[] =>\r\n{\r\n    let titles: string[] = [];\r\n    \r\n    // Debug only owing to API issue mentioned below\r\n    let temp = Math.random() * 50;\r\n    if(coinFlip()) temp *= -1; // Make negative\r\n\r\n    for(let i = 0; i <= TITLES_TO_GENERATE; i++)\r\n    {\r\n        let title = \"\";\r\n\r\n        if(coinFlip()) title += TITLE_PREFIXS[Math.floor(Math.random() * TITLE_PREFIXS.length)];\r\n        else if(coinFlip() && album.photos[0].weekend) \r\n        {\r\n            if(coinFlip()) title += album.weather;\r\n            title +=  coinFlip() ? \" weekend in \" : \" weekend away in \";\r\n        }\r\n        else title += album.weather + \" day in \";\r\n        \r\n        \r\n        if(coinFlip()) \r\n        {\r\n            // Normally we'd pull this from here, but as we're in a bit of a pickle with an awkward API\r\n            // we'll randomly generate a fixed temperature for the day.\r\n            //const temp = album.averageTemperature;\r\n            if(temp <= 0)\r\n            {\r\n                title += 'cold ';\r\n            }\r\n            else if(temp >= 30)\r\n            {\r\n                title += 'hot ';\r\n            }\r\n            else if(temp >= 15)\r\n            {\r\n                title += 'warm ';\r\n            }\r\n            else if(temp >= 10)\r\n            {\r\n                title += 'mild ';\r\n            }\r\n            else\r\n            {\r\n                title += 'nippy ';\r\n            }\r\n        }\r\n\r\n        if(coinFlip()) title += album.country;\r\n        else title += album.photos[0].state;\r\n        \r\n        // Avoid adding the same title\r\n        if(titles.includes(title))\r\n        {\r\n            i--;\r\n        }\r\n        else\r\n        {\r\n            // Push the latest generated title but be sure to uppercase the first letter\r\n            titles.push(title.charAt(0).toUpperCase() + title.slice(1));\r\n        }\r\n    }\r\n    return titles;\r\n} \r\n\r\nexport {generateTitles};","import { Album, Photo, PhotoMetaData } from \"../models/Album\";\r\nimport { Coordinates } from \"../models/Utils\";\r\nimport { getLocationDateForPhoto, getWeatherOnDate } from \"../services\";\r\nimport { generateTitles } from \"./TitleGenerator\";\r\n\r\n// Radius of the earth\r\nconst RADIUS = 6371;\r\nconst DEGREE = 180;\r\n\r\n// Constraints for requerying endpoints\r\nconst MAX_DISTANCE_KM = 5;\r\n\r\n/**\r\n * \r\n * MIT License, refactored from \r\n * https://github.com/thealmarques/haversine-distance-typescript/blob/master/index.ts\r\n * \r\n * Calculates the distance (in kms) between point A and B using earth's radius as the spherical surface\r\n * @param pointA Coordinates from Point A\r\n * @param pointB Coordinates from Point B\r\n * Based on https://www.movable-type.co.uk/scripts/latlong.html\r\n */\r\nconst getEstimatedDistance = (pointA: Coordinates, pointB: Coordinates): number => { \r\n\r\n    // convert latitude and longitude to radians\r\n    const deltaLatitude = (pointB.latitude - pointA.latitude) * Math.PI / DEGREE;\r\n    const deltaLongitude = (pointB.longitude - pointA.longitude) * Math.PI / DEGREE;\r\n\r\n    const halfChordLength = Math.cos(\r\n        pointA.latitude * Math.PI / DEGREE) * Math.cos(pointB.latitude * Math.PI / DEGREE) \r\n        * Math.sin(deltaLongitude/2) * Math.sin(deltaLongitude/2)\r\n        + Math.sin(deltaLatitude/2) * Math.sin(deltaLatitude/2);\r\n\r\n    const angularDistance = 2 * Math.atan2(Math.sqrt(halfChordLength), Math.sqrt(1 - halfChordLength));\r\n\r\n    return RADIUS * angularDistance;\r\n}\r\n\r\nconst parseCSVDataIntoMetaData = (data: string[]): PhotoMetaData[] => {\r\n    return data.map((row) => {\r\n        const [timestamp, latitude, longitude] = row.split(',');\r\n        return {timestamp, coordinates: {latitude: +latitude, longitude: +longitude}} as PhotoMetaData;\r\n    });\r\n}\r\n\r\nconst parseMetaDataIntoPhotoArray = async (metaData: PhotoMetaData[]): Promise<Photo[]> => {\r\n    \r\n    let lastPhoto: Photo = undefined!;\r\n\r\n    let photos: Photo[] = [];\r\n\r\n    for(const data of metaData)\r\n    {\r\n        const lat = data.coordinates.latitude;\r\n        const long = data.coordinates.longitude;\r\n  \r\n        const newPhotoTime = new Date(data.timestamp);\r\n  \r\n        let majorDistanceBetweenLastPhoto: boolean = true;\r\n        let majorTimeDifference: boolean = true;\r\n  \r\n        const newPhoto: Photo = {...lastPhoto};\r\n        newPhoto.coordinates = data.coordinates;\r\n        newPhoto.timestamp = data.timestamp;\r\n\r\n        // To avoid hitting the endpoint every single time, we only issue a fetch when we notice that either\r\n        // a. Massive distance change greater than ~5km in long/lat\r\n        // b. A day has passed between photographs\r\n        if(lastPhoto != undefined)\r\n        {\r\n          const oldPhotoTime = new Date(lastPhoto.timestamp);\r\n          // Calculate if the distance from the last photo is greater than the current photo\r\n          majorDistanceBetweenLastPhoto = getEstimatedDistance(lastPhoto.coordinates, data.coordinates) > MAX_DISTANCE_KM;\r\n          // We want to check if there is disparity in days, if so then this could affect weather, etc\r\n          majorTimeDifference = Math.ceil(Math.abs((oldPhotoTime.getTime() - newPhotoTime.getTime()) / 86400000)) > 1;\r\n        }\r\n\r\n        if(majorDistanceBetweenLastPhoto || majorTimeDifference)\r\n        {\r\n            try\r\n            {\r\n                const fetchGeoLocationData = await getLocationDateForPhoto(data.coordinates);\r\n                // This is an API call to a very restrictive end point that gets upset if we spam it often.\r\n                // Normally the format for retreiving the data from the JSON is:\r\n                // newPhoto.weather = temperatureData[0].hourly[3].weatherDesc[0].value;\r\n                // newPhoto.temperature = temperatureData[0].avgtempC;\r\n\r\n                //const temperatureData = await getWeatherOnDate(newPhotoTime.toISOString(), data.coordinates);\r\n                const address = fetchGeoLocationData.items[0].address;\r\n                newPhoto.country = address.countryName;\r\n                newPhoto.city = address.city;\r\n                newPhoto.state = address.state;\r\n                newPhoto.weekend = newPhotoTime.getDay() % 6 == 0;\r\n                newPhoto.weather = 'Sunny';\r\n                newPhoto.temperature = 15;\r\n            }\r\n            catch(error)\r\n            {\r\n                console.warn('Failed to identify metadata of photo - ' + error);\r\n            }\r\n        }\r\n\r\n        lastPhoto = newPhoto;\r\n        photos.push(newPhoto);\r\n    }\r\n\r\n    return photos;\r\n};\r\n\r\nconst parseMetaDataIntoAlbum = (photos: Photo[]): Album => {\r\n    let album: Album = \r\n    {\r\n        photos: photos,\r\n        suggestedTitles: [],\r\n        averageTemperature: photos.reduce((a, b) => a + (+b.temperature), 0) / photos.length,\r\n        country: photos[0].country,\r\n        weather: photos[0].weather\r\n    }\r\n    album.suggestedTitles = generateTitles(album);\r\n    return album;\r\n};\r\n\r\nexport {parseMetaDataIntoAlbum, parseCSVDataIntoMetaData, parseMetaDataIntoPhotoArray, getEstimatedDistance};","import './App.css';\r\nimport { getCSVFile } from './services';\r\nimport { Album, Photo, PhotoMetaData } from './models/Album';\r\nimport { parseCSVDataIntoMetaData, parseMetaDataIntoAlbum, parseMetaDataIntoPhotoArray } from './helpers/AlbumParser';\r\nimport { useState } from 'react';\r\n\r\nconst datasetUrls: string[] = \r\n[\r\n  'https://gist.githubusercontent.com/tomjcohen/726d24f1fe2736a16028911c3b544bfc/raw/4e85629b513c6fb15202b4d1410fc03e568a0dcb/1.csv',\r\n  'https://gist.githubusercontent.com/tomjcohen/726d24f1fe2736a16028911c3b544bfc/raw/4e85629b513c6fb15202b4d1410fc03e568a0dcb/2.csv',\r\n  'https://gist.githubusercontent.com/tomjcohen/726d24f1fe2736a16028911c3b544bfc/raw/4e85629b513c6fb15202b4d1410fc03e568a0dcb/3.csv',\r\n]\r\n\r\nconst getAlbumTitles = async () => {\r\n\r\n  // Iterate over 3 album URLs, and fetch their relevant CSV data\r\n  return Promise.all(datasetUrls.map( async (url)=>{\r\n    const data = await getCSVFile(url);\r\n    const rows = data.split('\\n');\r\n\r\n    // Generate some data\r\n    const metaData: PhotoMetaData[] = parseCSVDataIntoMetaData(rows);\r\n    const photoData: Photo[] = await parseMetaDataIntoPhotoArray(metaData);\r\n\r\n    // Create an album object from the photos\r\n    return parseMetaDataIntoAlbum(photoData);\r\n\r\n  }));\r\n}\r\n\r\nfunction App() {\r\n\r\n  const [albumTitles, setAlbumTitles] = useState<Album[]>([]);\r\n\r\n  const handleClick = async () => {\r\n    const albums = await getAlbumTitles();\r\n    setAlbumTitles(albums);\r\n  }\r\n\r\n  return (\r\n    <div style={{textAlign: 'center'}}>\r\n\r\n      <h1>Suggestions for Album Titles</h1>\r\n      <button onClick={handleClick}>Generate Titles</button>\r\n      <hr></hr>\r\n\r\n      <div>\r\n        {albumTitles.map((album, i) => (\r\n          <>\r\n            <div key={i}>\r\n              <h3>{album.country} - {album.weather} - {album.averageTemperature}°C</h3>\r\n            {album.suggestedTitles.map((title, j) => (\r\n                <div key={j}>{title}</div>\r\n            ) )}\r\n            </div>\r\n            <hr></hr>\r\n          </>\r\n        ) )}\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","import { ReportHandler } from 'web-vitals';\r\n\r\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\r\n  if (onPerfEntry && onPerfEntry instanceof Function) {\r\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\r\n      getCLS(onPerfEntry);\r\n      getFID(onPerfEntry);\r\n      getFCP(onPerfEntry);\r\n      getLCP(onPerfEntry);\r\n      getTTFB(onPerfEntry);\r\n    });\r\n  }\r\n};\r\n\r\nexport default reportWebVitals;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport reportWebVitals from './reportWebVitals';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n"],"sourceRoot":""}